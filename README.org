#+SETUPFILE: ~/org/conf/org-html-themes/setup/theme-readtheorg.setup

#+HTML_HEAD: <link rel="stylesheet" href="/home/sarthak/org/conf/css/rto_big.css" type="text/css">

#+OPTIONS: num:nil ^:nil \n:t H:6
#+TITLE: Eloquent JS notes

* Chapter 1 (Values, Types, and Operators)
** Notes
*** null and undefined comparison

 When the types differ, JavaScript uses a complicated and confusing
 set of rules to determine what to do. In most cases, it just tries to
 convert one of the values to the other value’s type. However, when
 ~null~ or ~undefined~ occurs on either side of the operator, it produces
 true only if both sides are one of ~null~ or ~undefined~.

 #+begin_src js :exports both :results output
// null or undefined on both sides means equal
console.log(null == undefined); //true
console.log(null !== undefined); //true

// null or undefined on only one side means not equal
console.log(null == 0); //false
console.log(null !== 0); //true
 #+end_src

 #+RESULTS:
 : true
 : true
 : false
 : true


 *Use ~===~ or ~!==~ operator if you don't want type conversion.*

 #+begin_src js :exports both :results output
// triple equal sign checks if it is the same thing without type conversion
console.log(null === null);
console.log(undefined === undefined);

// but two non-sensical values are not the same
console.log(NaN === NaN);
 #+end_src

 #+RESULTS:
 : true
 : true
 : false

*** || and && operators

 The ~||~ operator works like following(pseudocode):
 #+begin_src js :eval no
function ||(left, right) {
  if convertToBoolean(left) === True {
      return left;
  }
  return right
}
// For eg: 0 || 8 returns 8
// 0, NaN and empty string => false, others => true
 #+end_src

 #+RESULTS:

 The ~&&~ operator works the same way but  is the exact opposite(pseudocode):

 #+begin_src js :eval no
function &&(left, right) {
  if convertToBoolean(left) === False {
      return left;
  }
  return right;
}

// For eg: 0 && 8 returns 0
// 0, NaN and empty string => false, others => true
 #+end_src

* Chapter 2 (Program Structure)
** Exercises

*** Looping a triange
    Write a loop that makes seven calls to console.log to output the following triangle:
#+begin_example
#
##
###
####
#####
######
#######
#+end_example

**** Solution:
#+begin_src js :exports both :results output
for(let i = 0; i < 7; i++){
  for(let j = 0; j <= i; j++){
    process.stdout.write("#");
  }
  process.stdout.write("\n");
}
#+end_src

#+RESULTS:
: #
: ##
: ###
: ####
: #####
: ######
: #######

*** FizzBuzz
Write a program that uses console.log to print all the numbers from 1
to 100, with two exceptions. For numbers divisible by 3, print "Fizz"
instead of the number, and for numbers divisible by 5 (and not 3),
print "Buzz" instead.

When you have that working, modify your program to print "FizzBuzz"
for numbers that are divisible by both 3 and 5 (and still print "Fizz"
or "Buzz" for numbers divisible by only one of those).

**** Solution:
#+begin_src js :exports both :results output
for (let i = 1; i <= 100; i++) {
  if (i % 3 === 0 && i % 5 === 0) {
    console.log("FizzBuzz");
  } else if (i % 3 === 0) {
    console.log("Fizz");
  } else if (i % 5 === 0){
    console.log("Buzz");
  } else {
    console.log(i);
  }
}
#+end_src

#+RESULTS:
#+begin_example
1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
FizzBuzz
16
17
Fizz
19
Buzz
Fizz
22
23
Fizz
Buzz
26
Fizz
28
29
FizzBuzz
31
32
Fizz
34
Buzz
Fizz
37
38
Fizz
Buzz
41
Fizz
43
44
FizzBuzz
46
47
Fizz
49
Buzz
Fizz
52
53
Fizz
Buzz
56
Fizz
58
59
FizzBuzz
61
62
Fizz
64
Buzz
Fizz
67
68
Fizz
Buzz
71
Fizz
73
74
FizzBuzz
76
77
Fizz
79
Buzz
Fizz
82
83
Fizz
Buzz
86
Fizz
88
89
FizzBuzz
91
92
Fizz
94
Buzz
Fizz
97
98
Fizz
Buzz
#+end_example

*** CHESSBOARD
    Write a program that creates a string that represents an 8×8 grid, using newline characters to separate lines. At each position of the grid there is either a space or a "#" character. The characters should form a chessboard.

Passing this string to console.log should show something like this:
#+begin_example
 # # # #
# # # #
 # # # #
# # # #
 # # # #
# # # #
 # # # #
# # # #
#+end_example

When you have a program that generates this pattern, define a binding size = 8 and change the program so that it works for any size, outputting a grid of the given width and height.

**** Solution:


#+begin_src js :exports both :results output
let add_offset = false;
let size = 8;
for (let i = 0; i < size; i++) {
    for (let j = 0; j < size; j++) {
        if (j % 2 == 0) {
            process.stdout.write("#");
        } else {
            process.stdout.write(" ");
        }
    }
    process.stdout.write("\n");
    add_offset = !add_offset;
    if (add_offset) {
        process.stdout.write(" ");
    }
}
#+end_src

#+RESULTS:
: # # # #
:  # # # #
: # # # #
:  # # # #
: # # # #
:  # # # #
: # # # #
:  # # # #

* Chapter 3 (Functions)
** Notes

*** Creating local scope
~let~ and ~const~ are created within the local scope whereas ~var~ is visible throughout the global scope if called outside a function.
#+begin_src js  :exports both :results output
var x = 10;
if(1){
  var y = 20;
}

console.log(x);
console.log(y);

function test(){
  var k = 20;
}
// console.log(k)    // this throws ReferenceError
#+end_src

#+RESULTS:
: 10
: 20

#+begin_src js  :exports code :results output
if(1){
  let y = 20;
}

// console.log(y)    // this throws ReferenceError
#+end_src

*** Function declaration

Functions are conceptually moved to the top of their scope so we can define it later in the code.

#+begin_src js :results output
console.log("And in the end, he said: ", later());

function later() {
  return "Hero ko entry last ma huncha..";
}
#+end_src

#+RESULTS:
: And in the end, he said:  Hero ko entry last ma huncha..
: undefined

*** Extra or missing arguments
    JavaScript is extremely broad-minded about the number of arguments you pass to a function. If you pass too many, the extra ones are ignored. If you pass too few, the missing parameters get assigned the value undefined.

*** Closures

Inner functions(functions inside functions) in javascript keep track of their free variables even when the execution of the external function has finished.

A simple use case for closures:
#+begin_src js  :exports code :results output
function wrap_tag(tag){
  function content(msg){
    console.log("<" + tag + ">" + msg + "</" + tag + ">");
  }
  return content;
}

let h1_wrapped = wrap_tag("h1");
let heading_content = h1_wrapped("Welcome to my site!");

let paragraph_wrapped = wrap_tag("p");
let paragraph_content = paragraph_wrapped("This is the content");
#+end_src

#+RESULTS:
: <h1>Welcome to my site!</h1>
: <p>This is the content</p>

** Exercises

*** Minimum

The previous chapter introduced the standard function ~Math.min~ that
returns its smallest argument. We can build something like that
now. Write a function min that takes two arguments and returns their
minimum.

**** Solution:
     #+begin_src js :exports both :results output
function min(first, second) {
    if (first < second) {
        return first;
    }
    return second;
}

console.log(min(100, 20));
console.log(min(10, 20));
     #+end_src

     #+RESULTS:
     : 20
     : 10

*** RECURSION

We’ve seen that % (the remainder operator) can be used to test whether a number is even or odd by using % 2 to see whether it’s divisible by two. Here’s another way to define whether a positive whole number is even or odd:

    + Zero is even.

    + One is odd.

    + For any other number N, its evenness is the same as N - 2.

Define a recursive function isEven corresponding to this description. The function should accept a single parameter (a positive, whole number) and return a Boolean.

Test it on 50 and 75. See how it behaves on -1. Why? Can you think of a way to fix this?

**** Solution:
#+begin_src js :exports both :results output
function isEven(number) {
    if (number == 0) {
        return true;
    } else if (number == 1) {
        return false;
    }
    return isEven(number - 2);
}

console.log(isEven(50));
console.log(isEven(75));
// console.log(isEven(-1)); RangeError: Maximum call stack size exceeded
#+end_src

     #+RESULTS:
     : true
     : false

The reason behind the ~RangeError~ exception is that subtracting 2 from a negative number will make the number even smaller and it will never reach 0 or 1. Hence, the stack overflows. To fix this problem, we add 2 instead of subtracting if the number is less than 0, else we subtract 2:

#+begin_src js :exports both :results output
function isEven(number) {
    if (number == 0) {
        return true;
    } else if (number == 1) {
        return false;
    }

    if (number < 0) {
        return isEven(number + 2);
    } else {
        return isEven(number - 2);
    }

}

console.log(isEven(50));
console.log(isEven(75));
console.log(isEven(-1));
#+end_src

#+RESULTS:
: true
: false
: false

*** Bean Counting

You can get the Nth character, or letter, from a string by writing ~"string"[N]~. The returned value will be a string containing only one character (for example, "b"). The first character has position 0, which causes the last one to be found at position string.length - 1. In other words, a two-character string has length 2, and its characters have positions 0 and 1.

Write a function ~countBs~ that takes a string as its only argument and returns a number that indicates how many uppercase “B” characters there are in the string.

Next, write a function called countChar that behaves like countBs, except it takes a second argument that indicates the character that is to be counted (rather than counting only uppercase “B” characters). Rewrite countBs to make use of this new function.

**** Solution:
#+begin_src js :exports both :results output
function countBs(string) {
    let count = 0;
    for (let i = 0; i < string.length; i++) {
        if (string[i] === "B") {
            count++;
        }
    }
    return count;
}
console.log(countBs("BBBcccCB"));
#+end_src

     #+RESULTS:
     : 4

For ~countChar~:
#+begin_src js :exports both :results output
function countChar(string, character) {
    let count = 0;
    for (let i = 0; i < string.length; i++) {
        if (string[i] === character) {
            count++;
        }
    }
    return count;
}
console.log(countChar("BBBcccssCB", "c"));
#+end_src

#+RESULTS:
: 3
