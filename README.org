#+SETUPFILE: ~/org/conf/org-html-themes/setup/theme-readtheorg.setup

#+HTML_HEAD: <link rel="stylesheet" href="/home/sarthak/org/conf/css/rto_big.css" type="text/css">

#+OPTIONS: num:nil ^:nil \n:t H:6
#+TITLE: Eloquent JS notes

* Chapter 1 (Values, Types, and Operators)
** Notes
*** null and undefined comparison

 When the types differ, JavaScript uses a complicated and confusing
 set of rules to determine what to do. In most cases, it just tries to
 convert one of the values to the other value’s type. However, when
 ~null~ or ~undefined~ occurs on either side of the operator, it produces
 true only if both sides are one of ~null~ or ~undefined~.

 #+begin_src js :exports both :results output
// null or undefined on both sides means equal
console.log(null == undefined); //true
console.log(null !== undefined); //true

// null or undefined on only one side means not equal
console.log(null == 0); //false
console.log(null !== 0); //true
 #+end_src

 #+RESULTS:
 : true
 : true
 : false
 : true


 *Use ~===~ or ~!==~ operator if you don't want type conversion.*

 #+begin_src js :exports both :results output
// triple equal sign checks if it is the same thing without type conversion
console.log(null === null);
console.log(undefined === undefined);

// but two non-sensical values are not the same
console.log(NaN === NaN);
 #+end_src

 #+RESULTS:
 : true
 : true
 : false

*** || and && operators

 The ~||~ operator works like following(pseudocode):
 #+begin_src js :eval no
function ||(left, right) {
  if convertToBoolean(left) === True {
      return left;
  }
  return right
}
// For eg: 0 || 8 returns 8
// 0, NaN and empty string => false, others => true
 #+end_src

 #+RESULTS:

 The ~&&~ operator works the same way but  is the exact opposite(pseudocode):

 #+begin_src js :eval no
function &&(left, right) {
  if convertToBoolean(left) === False {
      return left;
  }
  return right;
}

// For eg: 0 && 8 returns 0
// 0, NaN and empty string => false, others => true
 #+end_src

* Chapter 2 (Program Structure)
** Exercises

*** Looping a triange
    Write a loop that makes seven calls to console.log to output the following triangle:
#+begin_example
#
##
###
####
#####
######
#######
#+end_example

**** Solution:
#+begin_src js :exports both :results output
for(let i = 0; i < 7; i++){
  for(let j = 0; j <= i; j++){
    process.stdout.write("#");
  }
  process.stdout.write("\n");
}
#+end_src

#+RESULTS:
: #
: ##
: ###
: ####
: #####
: ######
: #######

*** FizzBuzz
Write a program that uses console.log to print all the numbers from 1
to 100, with two exceptions. For numbers divisible by 3, print "Fizz"
instead of the number, and for numbers divisible by 5 (and not 3),
print "Buzz" instead.

When you have that working, modify your program to print "FizzBuzz"
for numbers that are divisible by both 3 and 5 (and still print "Fizz"
or "Buzz" for numbers divisible by only one of those).

**** Solution:
#+begin_src js :exports both :results output
for (let i = 1; i <= 100; i++) {
  if (i % 3 === 0 && i % 5 === 0) {
    console.log("FizzBuzz");
  } else if (i % 3 === 0) {
    console.log("Fizz");
  } else if (i % 5 === 0){
    console.log("Buzz");
  } else {
    console.log(i);
  }
}
#+end_src

#+RESULTS:
#+begin_example
1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
FizzBuzz
16
17
Fizz
19
Buzz
Fizz
22
23
Fizz
Buzz
26
Fizz
28
29
FizzBuzz
31
32
Fizz
34
Buzz
Fizz
37
38
Fizz
Buzz
41
Fizz
43
44
FizzBuzz
46
47
Fizz
49
Buzz
Fizz
52
53
Fizz
Buzz
56
Fizz
58
59
FizzBuzz
61
62
Fizz
64
Buzz
Fizz
67
68
Fizz
Buzz
71
Fizz
73
74
FizzBuzz
76
77
Fizz
79
Buzz
Fizz
82
83
Fizz
Buzz
86
Fizz
88
89
FizzBuzz
91
92
Fizz
94
Buzz
Fizz
97
98
Fizz
Buzz
#+end_example

*** CHESSBOARD
    Write a program that creates a string that represents an 8×8 grid, using newline characters to separate lines. At each position of the grid there is either a space or a "#" character. The characters should form a chessboard.

Passing this string to console.log should show something like this:
#+begin_example
 # # # #
# # # #
 # # # #
# # # #
 # # # #
# # # #
 # # # #
# # # #
#+end_example

When you have a program that generates this pattern, define a binding size = 8 and change the program so that it works for any size, outputting a grid of the given width and height.

**** Solution:


#+begin_src js :exports both :results output
let add_offset = false;
let size = 8;
for (let i = 0; i < size; i++) {
    for (let j = 0; j < size; j++) {
        if (j % 2 == 0) {
            process.stdout.write("#");
        } else {
            process.stdout.write(" ");
        }
    }
    process.stdout.write("\n");
    add_offset = !add_offset;
    if (add_offset) {
        process.stdout.write(" ");
    }
}
#+end_src

#+RESULTS:
: # # # #
:  # # # #
: # # # #
:  # # # #
: # # # #
:  # # # #
: # # # #
:  # # # #

* Chapter 3 (Functions)
** Notes

*** Creating local scope
~let~ and ~const~ are created within the local scope whereas ~var~ is visible throughout the global scope if called outside a function.
#+begin_src js  :exports both :results output
var x = 10;
if(1){
  var y = 20;
}

console.log(x);
console.log(y);

function test(){
  var k = 20;
}
// console.log(k)    // this throws ReferenceError
#+end_src

#+RESULTS:
: 10
: 20

#+begin_src js  :exports code :results output
if(1){
  let y = 20;
}

// console.log(y)    // this throws ReferenceError
#+end_src

*** Function declaration

Functions are conceptually moved to the top of their scope so we can define it later in the code.

#+begin_src js
console.log("And in the end, he said: ", later());

function later() {
  return "Hero ko entry last ma huncha..";
}
#+end_src

*** Extra or missing arguments
    JavaScript is extremely broad-minded about the number of arguments you pass to a function. If you pass too many, the extra ones are ignored. If you pass too few, the missing parameters get assigned the value undefined.

*** Closures

Inner functions(functions inside functions) in javascript keep track of their free variables even when the execution of the external function has finished.

A simple use case for closures:
#+begin_src js  :exports code :results output
function wrap_tag(tag){
  function content(msg){
    console.log("<" + tag + ">" + msg + "</" + tag + ">");
  }
  return content;
}

let h1_wrapped = wrap_tag("h1");
let heading_content = h1_wrapped("Welcome to my site!");

let paragraph_wrapped = wrap_tag("p");
let paragraph_content = paragraph_wrapped("This is the content");
#+end_src

#+RESULTS:
: <h1>Welcome to my site!</h1>
: <p>This is the content</p>
